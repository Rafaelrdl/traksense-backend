# Generated manually - Fase R - Opção A
# Continuous Aggregate 1m com compressão para dados numéricos

from django.db import migrations


class Migration(migrations.Migration):
    """
    Continuous Aggregate 1m (1 minuto) - APENAS dados numéricos
    
    Estratégia:
    ----------
    - Agrega v_num (valores numéricos) com AVG, MAX, MIN, COUNT
    - Ignora v_bool e v_text (não agregáveis)
    - Compressão habilitada (compatível - CAGGs NÃO têm RLS)
    - Retenção: 365 dias (1 ano de histórico agregado)
    
    Políticas:
    ---------
    1. Refresh: a cada 1 minuto, janela [now()-14d, now()-1m]
       - start_offset=14d alinhado com retenção do raw
    2. Compressão: chunks > 7 dias (~10x redução de storage)
    3. Retenção: dados > 365 dias deletados automaticamente
    
    Performance:
    -----------
    - Índice: (tenant_id, device_id, point_id, bucket DESC)
    - Query típica: filtro por tenant+device+point + range bucket
    - Compressão reduz I/O em ~90% para queries históricas
    
    API Usage:
    ---------
    - GET /data/points?agg=1m → usa este CAGG
    - Janelas > 14 dias com agg=raw → degrade automático para 1m
    """

    dependencies = [
        ('timeseries', '0005_raw_no_compress_short_retention'),
    ]

    operations = [
        # ============================================================================
        # 1. CREATE CONTINUOUS AGGREGATE VIEW
        # ============================================================================
        migrations.RunSQL(
            sql="""
            -- Limpar view/materialized view existente (se houver)
            DROP VIEW IF EXISTS public.ts_measure_1m CASCADE;
            DROP MATERIALIZED VIEW IF EXISTS public.ts_measure_1m CASCADE;
            
            -- Criar continuous aggregate para 1 minuto (apenas numéricos)
            CREATE MATERIALIZED VIEW public.ts_measure_1m
            WITH (timescaledb.continuous) AS
            SELECT 
                time_bucket('1 minute', ts) AS bucket,
                tenant_id,
                device_id,
                point_id,
                AVG(v_num) AS v_avg,
                MAX(v_num) AS v_max,
                MIN(v_num) AS v_min,
                COUNT(v_num) AS n
            FROM public.ts_measure
            WHERE v_num IS NOT NULL  -- apenas valores numéricos
            GROUP BY bucket, tenant_id, device_id, point_id
            WITH NO DATA;  -- não materializar agora (será feito por refresh policy)
            
            -- Comentário explicativo
            COMMENT ON MATERIALIZED VIEW public.ts_measure_1m IS
            'Continuous Aggregate 1 minuto - dados numéricos (v_num).
             
             Campos:
             - bucket: timestamp do bucket (1 min)
             - tenant_id, device_id, point_id: identificadores
             - v_avg: média do v_num no bucket
             - v_max: máximo do v_num no bucket
             - v_min: mínimo do v_num no bucket
             - n: quantidade de amostras no bucket
             
             Refresh: a cada 1min, janela [now()-14d, now()-1m]
             Compressão: chunks > 7 dias
             Retenção: 365 dias (1 ano)
             
             API: GET /data/points?agg=1m → usa esta view
             ====================================================';
            """,
            reverse_sql="""
            DROP MATERIALIZED VIEW IF EXISTS public.ts_measure_1m CASCADE;
            """
        ),
        
        # ============================================================================
        # 2. CRIAR ÍNDICE PARA PERFORMANCE
        # ============================================================================
        migrations.RunSQL(
            sql="""
            -- Índice para queries típicas: filtro por tenant+device+point + range bucket
            CREATE INDEX IF NOT EXISTS ts_measure_1m_tenant_device_point_bucket_idx
                ON public.ts_measure_1m (tenant_id, device_id, point_id, bucket DESC);
            
            -- Comentário do índice
            COMMENT ON INDEX public.ts_measure_1m_tenant_device_point_bucket_idx IS
            'Índice para queries: WHERE tenant_id=X AND device_id=Y AND point_id=Z AND bucket BETWEEN A AND B';
            """,
            reverse_sql="""
            DROP INDEX IF EXISTS public.ts_measure_1m_tenant_device_point_bucket_idx;
            """
        ),
        
        # ============================================================================
        # 3. REFRESH POLICY (materialização automática)
        # ============================================================================
        migrations.RunSQL(
            sql="""
            -- Remover policy existente (se houver)
            SELECT remove_continuous_aggregate_policy('public.ts_measure_1m', if_exists => true);
            
            -- Adicionar refresh policy
            -- start_offset: 14 dias (alinhado com retenção do raw)
            -- end_offset: 1 minuto (evitar dados ainda sendo ingeridos)
            -- schedule_interval: a cada 1 minuto
            SELECT add_continuous_aggregate_policy(
                'public.ts_measure_1m',
                start_offset => INTERVAL '14 days',
                end_offset   => INTERVAL '1 minute',
                schedule_interval => INTERVAL '1 minute',
                if_not_exists => true
            );
            
            DO $$ BEGIN
                RAISE NOTICE 'Refresh policy configurada: ts_measure_1m refresh a cada 1min';
            END $$;
            """,
            reverse_sql="""
            SELECT remove_continuous_aggregate_policy('public.ts_measure_1m', if_exists => true);
            """
        ),
        
        # ============================================================================
        # 4. HABILITAR COMPRESSÃO (CAGGs não têm RLS - compatível!)
        # ============================================================================
        migrations.RunSQL(
            sql="""
            -- CAGGs NÃO têm RLS, portanto compressão é COMPATÍVEL
            -- TimescaleDB automaticamente aplica compressão na hypertable interna
            ALTER MATERIALIZED VIEW public.ts_measure_1m
                SET (timescaledb.compress = true);
            
            DO $$ BEGIN
                RAISE NOTICE 'Compressão habilitada: ts_measure_1m (compatível - sem RLS)';
            END $$;
            """,
            reverse_sql="""
            -- Desabilitar compressão (se necessário rollback)
            ALTER MATERIALIZED VIEW public.ts_measure_1m
                SET (timescaledb.compress = false);
            """
        ),
        
        # ============================================================================
        # 5. COMPRESSION POLICY (comprimir chunks antigos)
        # ============================================================================
        migrations.RunSQL(
            sql="""
            -- Remover policy existente (se houver)
            DO $$ 
            BEGIN
                PERFORM remove_compression_policy('public.ts_measure_1m', if_exists => true);
            EXCEPTION 
                WHEN OTHERS THEN
                    RAISE NOTICE 'Nenhuma compression policy para remover';
            END $$;
            
            -- Adicionar compression policy
            -- Chunks com > 7 dias serão comprimidos automaticamente
            SELECT add_compression_policy(
                'public.ts_measure_1m',
                INTERVAL '7 days',
                if_not_exists => true
            );
            
            DO $$ BEGIN
                RAISE NOTICE 'Compression policy configurada: ts_measure_1m comprime após 7d';
            END $$;
            """,
            reverse_sql="""
            DO $$ 
            BEGIN
                PERFORM remove_compression_policy('public.ts_measure_1m', if_exists => true);
            EXCEPTION 
                WHEN OTHERS THEN NULL;
            END $$;
            """
        ),
        
        # ============================================================================
        # 6. RETENTION POLICY (deletar dados antigos)
        # ============================================================================
        migrations.RunSQL(
            sql="""
            -- Remover policy existente (se houver)
            DO $$ 
            BEGIN
                PERFORM remove_retention_policy('public.ts_measure_1m', if_exists => true);
            EXCEPTION 
                WHEN OTHERS THEN
                    RAISE NOTICE 'Nenhuma retention policy para remover';
            END $$;
            
            -- Adicionar retention policy
            -- Dados com > 365 dias (1 ano) serão deletados automaticamente
            SELECT add_retention_policy(
                'public.ts_measure_1m',
                INTERVAL '365 days',
                if_not_exists => true
            );
            
            DO $$ BEGIN
                RAISE NOTICE 'Retention policy configurada: ts_measure_1m mantém 365d (1 ano)';
            END $$;
            """,
            reverse_sql="""
            DO $$ 
            BEGIN
                PERFORM remove_retention_policy('public.ts_measure_1m', if_exists => true);
            EXCEPTION 
                WHEN OTHERS THEN NULL;
            END $$;
            """
        ),
        
        # ============================================================================
        # 7. MATERIALIZAÇÃO INICIAL (primeiros dados)
        # ============================================================================
        migrations.RunSQL(
            sql="""
            -- Materializar dados dos últimos 14 dias (se existirem)
            -- Isso pode demorar alguns segundos dependendo do volume de dados
            DO $$ 
            BEGIN
                CALL refresh_continuous_aggregate(
                    'public.ts_measure_1m',
                    now() - INTERVAL '14 days',
                    now()
                );
                RAISE NOTICE 'Materialização inicial completa: ts_measure_1m (últimos 14d)';
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE NOTICE 'Materialização inicial: sem dados para materializar ou erro: %', SQLERRM;
            END $$;
            """,
            reverse_sql=migrations.RunSQL.noop
        ),
    ]
