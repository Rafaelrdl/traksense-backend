# Generated manually - Fase R - Opção A
# Continuous Aggregate 1h com compressão para dados numéricos

from django.db import migrations


class Migration(migrations.Migration):
    """
    Continuous Aggregate 1h (1 hora) - APENAS dados numéricos
    
    Estratégia:
    ----------
    - Agrega v_num do raw para máxima retenção histórica
    - Compressão habilitada (CAGGs não têm RLS)
    - Retenção: 1825 dias (~60 meses / 5 anos)
    
    Políticas:
    ---------
    1. Refresh: a cada 1 hora, janela [now()-1095d, now()-1h]
       - start_offset=1095d (3 anos) cobre período histórico extenso
    2. Compressão: chunks > 14 dias (~10x redução de storage)
    3. Retenção: dados > 1825 dias deletados automaticamente
    
    Performance:
    -----------
    - Índice: (tenant_id, device_id, point_id, bucket DESC)
    - Query típica: filtro por tenant+device+point + range bucket
    - Ideal para dashboards de meses/anos
    
    API Usage:
    ---------
    - GET /data/points?agg=1h → usa este CAGG
    - Janelas muito longas (>30 dias) → 1h reduz payload drasticamente
    - Relatórios anuais/históricos → usa este CAGG
    """

    dependencies = [
        ('timeseries', '0006_cagg_1m_create'),  # Temporário: pular 0007 por enquanto
    ]

    operations = [
        # ============================================================================
        # 1. CREATE CONTINUOUS AGGREGATE VIEW
        # ============================================================================
        migrations.RunSQL(
            sql="""
            -- Limpar view/materialized view existente (se houver)
            DROP VIEW IF EXISTS public.ts_measure_1h CASCADE;
            DROP MATERIALIZED VIEW IF EXISTS public.ts_measure_1h CASCADE;
            
            -- Criar continuous aggregate para 1 hora (apenas numéricos)
            CREATE MATERIALIZED VIEW public.ts_measure_1h
            WITH (timescaledb.continuous) AS
            SELECT 
                time_bucket('1 hour', ts) AS bucket,
                tenant_id,
                device_id,
                point_id,
                AVG(v_num) AS v_avg,
                MAX(v_num) AS v_max,
                MIN(v_num) AS v_min,
                COUNT(v_num) AS n
            FROM public.ts_measure
            WHERE v_num IS NOT NULL  -- apenas valores numéricos
            GROUP BY bucket, tenant_id, device_id, point_id
            WITH NO DATA;  -- não materializar agora (será feito por refresh policy)
            
            -- Comentário explicativo
            COMMENT ON MATERIALIZED VIEW public.ts_measure_1h IS
            'Continuous Aggregate 1 hora - dados numéricos (v_num).
             
             Campos:
             - bucket: timestamp do bucket (1 hora)
             - tenant_id, device_id, point_id: identificadores
             - v_avg: média do v_num no bucket
             - v_max: máximo do v_num no bucket
             - v_min: mínimo do v_num no bucket
             - n: quantidade de amostras no bucket
             
             Refresh: a cada 1h, janela [now()-1095d, now()-1h]
             Compressão: chunks > 14 dias
             Retenção: 1825 dias (~60 meses / 5 anos)
             
             API: GET /data/points?agg=1h → usa esta view
             Ideal para: dashboards de meses/anos, relatórios históricos
             ===========================================================';
            """,
            reverse_sql="""
            DROP MATERIALIZED VIEW IF EXISTS public.ts_measure_1h CASCADE;
            """
        ),
        
        # ============================================================================
        # 2. CRIAR ÍNDICE PARA PERFORMANCE
        # ============================================================================
        migrations.RunSQL(
            sql="""
            -- Índice para queries típicas: filtro por tenant+device+point + range bucket
            CREATE INDEX IF NOT EXISTS ts_measure_1h_tenant_device_point_bucket_idx
                ON public.ts_measure_1h (tenant_id, device_id, point_id, bucket DESC);
            
            -- Comentário do índice
            COMMENT ON INDEX public.ts_measure_1h_tenant_device_point_bucket_idx IS
            'Índice para queries: WHERE tenant_id=X AND device_id=Y AND point_id=Z AND bucket BETWEEN A AND B';
            """,
            reverse_sql="""
            DROP INDEX IF EXISTS public.ts_measure_1h_tenant_device_point_bucket_idx;
            """
        ),
        
        # ============================================================================
        # 3. REFRESH POLICY (materialização automática)
        # ============================================================================
        migrations.RunSQL(
            sql="""
            -- Remover policy existente (se houver)
            SELECT remove_continuous_aggregate_policy('public.ts_measure_1h', if_exists => true);
            
            -- Adicionar refresh policy
            -- start_offset: 1095 dias (3 anos - cobre histórico extenso)
            -- end_offset: 1 hora (evitar dados ainda sendo ingeridos)
            -- schedule_interval: a cada 1 hora
            SELECT add_continuous_aggregate_policy(
                'public.ts_measure_1h',
                start_offset => INTERVAL '1095 days',
                end_offset   => INTERVAL '1 hour',
                schedule_interval => INTERVAL '1 hour',
                if_not_exists => true
            );
            
            RAISE NOTICE 'Refresh policy configurada: ts_measure_1h refresh a cada 1h';
            """,
            reverse_sql="""
            SELECT remove_continuous_aggregate_policy('public.ts_measure_1h', if_exists => true);
            """
        ),
        
        # ============================================================================
        # 4. HABILITAR COMPRESSÃO
        # ============================================================================
        migrations.RunSQL(
            sql="""
            -- CAGGs NÃO têm RLS, portanto compressão é COMPATÍVEL
            ALTER MATERIALIZED VIEW public.ts_measure_1h
                SET (timescaledb.compress = true);
            
            RAISE NOTICE 'Compressão habilitada: ts_measure_1h (compatível - sem RLS)';
            """,
            reverse_sql="""
            ALTER MATERIALIZED VIEW public.ts_measure_1h
                SET (timescaledb.compress = false);
            """
        ),
        
        # ============================================================================
        # 5. COMPRESSION POLICY
        # ============================================================================
        migrations.RunSQL(
            sql="""
            -- Remover policy existente (se houver)
            SELECT remove_compression_policy('public.ts_measure_1h', if_exists => true);
            
            -- Adicionar compression policy
            -- Chunks com > 14 dias serão comprimidos automaticamente
            SELECT add_compression_policy(
                'public.ts_measure_1h',
                INTERVAL '14 days',
                if_not_exists => true
            );
            
            RAISE NOTICE 'Compression policy configurada: ts_measure_1h comprime após 14d';
            """,
            reverse_sql="""
            SELECT remove_compression_policy('public.ts_measure_1h', if_exists => true);
            """
        ),
        
        # ============================================================================
        # 6. RETENTION POLICY
        # ============================================================================
        migrations.RunSQL(
            sql="""
            -- Remover policy existente (se houver)
            SELECT remove_retention_policy('public.ts_measure_1h', if_exists => true);
            
            -- Adicionar retention policy
            -- Dados com > 1825 dias (~60 meses / 5 anos) serão deletados automaticamente
            SELECT add_retention_policy(
                'public.ts_measure_1h',
                INTERVAL '1825 days',
                if_not_exists => true
            );
            
            RAISE NOTICE 'Retention policy configurada: ts_measure_1h mantém 1825d (~60 meses / 5 anos)';
            """,
            reverse_sql="""
            SELECT remove_retention_policy('public.ts_measure_1h', if_exists => true);
            """
        ),
        
        # ============================================================================
        # 7. MATERIALIZAÇÃO INICIAL
        # ============================================================================
        migrations.RunSQL(
            sql="""
            -- Materializar dados dos últimos 1095 dias (se existirem)
            -- Isso pode demorar bastante dependendo do volume de dados
            -- Em produção, considerar materializar em batches
            CALL refresh_continuous_aggregate(
                'public.ts_measure_1h',
                now() - INTERVAL '1095 days',
                now()
            );
            
            RAISE NOTICE 'Materialização inicial completa: ts_measure_1h (últimos 1095d / 3 anos)';
            """,
            reverse_sql=migrations.RunSQL.noop
        ),
    ]
